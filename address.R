# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r test.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  delayedAssign(defName,  .values, assign.env = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_AddressBook__Point', contains = 'C++Reference')
setClass("AddressBook::Point",
    representation(
        x = "numeric",
        y = "numeric"),
        contains = "RSWIGStruct")


# End class AddressBook::Point

setClass('_p_AddressBook__Address', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of Point_x_set

`Point_x_set` = function(self, s_x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Point_x_set', self, s_x, PACKAGE='address');
  
}

attr(`Point_x_set`, 'returnType') = 'void'
attr(`Point_x_set`, "inputTypes") = c('_p_AddressBook__Point', 'numeric')
class(`Point_x_set`) = c("SWIGFunction", class('Point_x_set'))

# Start of Point_x_get

`Point_x_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Point_x_get', self, as.logical(.copy), PACKAGE='address');
  
}

attr(`Point_x_get`, 'returnType') = 'numeric'
attr(`Point_x_get`, "inputTypes") = c('_p_AddressBook__Point')
class(`Point_x_get`) = c("SWIGFunction", class('Point_x_get'))

# Start of Point_y_set

`Point_y_set` = function(self, s_y)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Point_y_set', self, s_y, PACKAGE='address');
  
}

attr(`Point_y_set`, 'returnType') = 'void'
attr(`Point_y_set`, "inputTypes") = c('_p_AddressBook__Point', 'numeric')
class(`Point_y_set`) = c("SWIGFunction", class('Point_y_set'))

# Start of Point_y_get

`Point_y_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Point_y_get', self, as.logical(.copy), PACKAGE='address');
  
}

attr(`Point_y_get`, 'returnType') = 'numeric'
attr(`Point_y_get`, "inputTypes") = c('_p_AddressBook__Point')
class(`Point_y_get`) = c("SWIGFunction", class('Point_y_get'))

# Start of new_Point

`Point` = function()
{
  ;ans = .Call('R_swig_new_Point', PACKAGE='address');
  ans <- if (is.null(ans)) ans
  else new("_p_AddressBook__Point", ref=ans);
  
  reg.finalizer(ans@ref, delete_Point);
  ans
  
}

attr(`Point`, 'returnType') = '_p_AddressBook__Point'
class(`Point`) = c("SWIGFunction", class('Point'))

# Start of delete_Point

`delete_Point` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Point', self, PACKAGE='address');
  
}

attr(`delete_Point`, 'returnType') = 'void'
attr(`delete_Point`, "inputTypes") = c('_p_AddressBook__Point')
class(`delete_Point`) = c("SWIGFunction", class('delete_Point'))

# Start of accessor method for AddressBook::Point
setMethod('$', '_p_AddressBook__Point', function(x, name)

{
  accessorFuns = list('x' = Point_x_get, 'y' = Point_y_get);
  vaccessors = c('x', 'y');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for AddressBook::Point
# Start of accessor method for AddressBook::Point
setMethod('$<-', '_p_AddressBook__Point', function(x, name, value)

{
  accessorFuns = list('x' = Point_x_set, 'y' = Point_y_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_AddressBook__Point', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('x' = Point_x_set, 'y' = Point_y_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for AddressBook::Point
setMethod('delete', '_p_AddressBook__Point', function(obj) {delete_AddressBook__Point(obj)})
# Start definition of copy functions & methods for AddressBook::Point
CopyToR_AddressBook__Point = function(value, obj = new("AddressBook::Point"))
{
  obj@x = value$x;
  obj@y = value$y;
  obj;
}



CopyToC_AddressBook__Point = function(value, obj)
{
  obj$x = value@x;
  obj$y = value@y;
  obj
}



# Start definition of copy methods for AddressBook::Point
setMethod('copyToR', '_p_AddressBook__Point', CopyToR_AddressBook__Point);
setMethod('copyToC', 'AddressBook::Point', CopyToC_AddressBook__Point);

# End definition of copy methods for AddressBook::Point
# End definition of copy functions & methods for AddressBook::Point
# Start of LocationType_Home_get

`LocationType_Home_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_LocationType_Home_get', as.logical(.copy), PACKAGE='address');
  ans = enumFromInteger(ans, "_AddressBook__LocationType");
  
  ans
  
}

attr(`LocationType_Home_get`, 'returnType') = 'character'
class(`LocationType_Home_get`) = c("SWIGFunction", class('LocationType_Home_get'))

# Start of LocationType_Work_get

`LocationType_Work_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_LocationType_Work_get', as.logical(.copy), PACKAGE='address');
  ans = enumFromInteger(ans, "_AddressBook__LocationType");
  
  ans
  
}

attr(`LocationType_Work_get`, 'returnType') = 'character'
class(`LocationType_Work_get`) = c("SWIGFunction", class('LocationType_Work_get'))

# Start of LocationType_Other_get

`LocationType_Other_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_LocationType_Other_get', as.logical(.copy), PACKAGE='address');
  ans = enumFromInteger(ans, "_AddressBook__LocationType");
  
  ans
  
}

attr(`LocationType_Other_get`, 'returnType') = 'character'
class(`LocationType_Other_get`) = c("SWIGFunction", class('LocationType_Other_get'))

# Start of new_Address

`Address` = function(street, city, l, p)
{
  street = as(street, "character"); 
  city = as(city, "character"); 
  l = enumToInteger(l, "_AddressBook__LocationType"); 
  
  if(length(l) > 1) {
    warning("using only the first element of l");
  };
  
  if (inherits(p, "ExternalReference")) p = slot(p,"ref"); 
  ;ans = .Call('R_swig_new_Address', street, city, l, p, PACKAGE='address');
  ans <- if (is.null(ans)) ans
  else new("_p_AddressBook__Address", ref=ans);
  
  reg.finalizer(ans@ref, delete_Address);
  ans
  
}

attr(`Address`, 'returnType') = '_p_AddressBook__Address'
attr(`Address`, "inputTypes") = c('character', 'character', 'character', '_p_AddressBook__Point')
class(`Address`) = c("SWIGFunction", class('Address'))

# Start of delete_Address

`delete_Address` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Address', self, PACKAGE='address');
  
}

attr(`delete_Address`, 'returnType') = 'void'
attr(`delete_Address`, "inputTypes") = c('_p_AddressBook__Address')
class(`delete_Address`) = c("SWIGFunction", class('delete_Address'))

# Start of Address_setStreet

`Address_setStreet` = function(self, street)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  street = as(street, "character"); 
  ;.Call('R_swig_Address_setStreet', self, street, PACKAGE='address');
  
}

attr(`Address_setStreet`, 'returnType') = 'void'
attr(`Address_setStreet`, "inputTypes") = c('_p_AddressBook__Address', 'character')
class(`Address_setStreet`) = c("SWIGFunction", class('Address_setStreet'))

# Start of Address_getStreet

`Address_getStreet` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Address_getStreet', self, PACKAGE='address');
  
}

attr(`Address_getStreet`, 'returnType') = 'character'
attr(`Address_getStreet`, "inputTypes") = c('_p_AddressBook__Address')
class(`Address_getStreet`) = c("SWIGFunction", class('Address_getStreet'))

# Start of Address_setCity

`Address_setCity` = function(self, city)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  city = as(city, "character"); 
  ;.Call('R_swig_Address_setCity', self, city, PACKAGE='address');
  
}

attr(`Address_setCity`, 'returnType') = 'void'
attr(`Address_setCity`, "inputTypes") = c('_p_AddressBook__Address', 'character')
class(`Address_setCity`) = c("SWIGFunction", class('Address_setCity'))

# Start of Address_getCity

`Address_getCity` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Address_getCity', self, PACKAGE='address');
  
}

attr(`Address_getCity`, 'returnType') = 'character'
attr(`Address_getCity`, "inputTypes") = c('_p_AddressBook__Address')
class(`Address_getCity`) = c("SWIGFunction", class('Address_getCity'))

# Start of Address_setLocationType

`Address_setLocationType` = function(self, l)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  l = enumToInteger(l, "_AddressBook__LocationType"); 
  
  if(length(l) > 1) {
    warning("using only the first element of l");
  };
  
  ;.Call('R_swig_Address_setLocationType', self, l, PACKAGE='address');
  
}

attr(`Address_setLocationType`, 'returnType') = 'void'
attr(`Address_setLocationType`, "inputTypes") = c('_p_AddressBook__Address', 'character')
class(`Address_setLocationType`) = c("SWIGFunction", class('Address_setLocationType'))

# Start of Address_getLocationType

`Address_getLocationType` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Address_getLocationType', self, as.logical(.copy), PACKAGE='address');
  ans = enumFromInteger(ans, "_AddressBook__LocationType");
  
  ans
  
}

attr(`Address_getLocationType`, 'returnType') = 'character'
attr(`Address_getLocationType`, "inputTypes") = c('_p_AddressBook__Address')
class(`Address_getLocationType`) = c("SWIGFunction", class('Address_getLocationType'))

# Start of Address_setPoint

`Address_setPoint` = function(self, p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(p, "ExternalReference")) p = slot(p,"ref"); 
  ;.Call('R_swig_Address_setPoint', self, p, PACKAGE='address');
  
}

attr(`Address_setPoint`, 'returnType') = 'void'
attr(`Address_setPoint`, "inputTypes") = c('_p_AddressBook__Address', '_p_AddressBook__Point')
class(`Address_setPoint`) = c("SWIGFunction", class('Address_setPoint'))

# Start of Address_getPoint

`Address_getPoint` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Address_getPoint', self, as.logical(.copy), PACKAGE='address');
  ans <- if (is.null(ans)) ans
  else new("_p_AddressBook__Point", ref=ans);
  
  ans
  
}

attr(`Address_getPoint`, 'returnType') = '_p_AddressBook__Point'
attr(`Address_getPoint`, "inputTypes") = c('_p_AddressBook__Address')
class(`Address_getPoint`) = c("SWIGFunction", class('Address_getPoint'))

# Start of accessor method for AddressBook::Address
setMethod('$', '_p_AddressBook__Address', function(x, name)

{
  accessorFuns = list('setStreet' = Address_setStreet, 'getStreet' = Address_getStreet, 'setCity' = Address_setCity, 'getCity' = Address_getCity, 'setLocationType' = Address_setLocationType, 'getLocationType' = Address_getLocationType, 'setPoint' = Address_setPoint, 'getPoint' = Address_getPoint);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for AddressBook::Address
setMethod('delete', '_p_AddressBook__Address', function(obj) {delete_AddressBook__Address(obj)})

defineEnumeration("_AddressBook__LocationType",
 .values=c("Home" = .Call('R_swig_LocationType_Home_get',FALSE, PACKAGE='address'),
"Work" = .Call('R_swig_LocationType_Work_get',FALSE, PACKAGE='address'),
"Other" = .Call('R_swig_LocationType_Other_get',FALSE, PACKAGE='address')))


